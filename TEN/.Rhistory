quantINT = seq(from = xmin, to = xmax, by = qstep)
xquant = rep(0, length(x))
for (i in 1:length(x)){
stop = 0
qlevel = 2
while (stop == 0){
if(x[i] <= quantINT[qlevel]) {
xquant[i] = qlevel -1
stop = 1}
else {
qlevel = qlevel +1
}
}
}
return(xquant)
}
Hquant(x, 5)
Hquant(x, 5) - 1
# used fo consistency with quantentr
Hquant = function(x, lev.q=15){
xmin = min(x)
xmax = max(x)
qstep = (xmax - xmin)/ lev.q
quantINT = seq(from = xmin, to = xmax, by = qstep)
xquant = rep(0, length(x))
for (i in 1:length(x)){
stop = 0
qlevel = 2
while (stop == 0){
if(x[i] <= quantINT[qlevel]) {
xquant[i] = qlevel -1
stop = 1}
else {
qlevel = qlevel +1
}
}
}
# change into return(xquant)
# used fo consistency with quantentr
}
Hquant(x, 5)
Hquant = function(x, lev.q=15){
xmin = min(x)
xmax = max(x)
qstep = (xmax - xmin)/ lev.q
quantINT = seq(from = xmin, to = xmax, by = qstep)
xquant = rep(0, length(x))
for (i in 1:length(x)){
stop = 0
qlevel = 2
while (stop == 0){
if(x[i] <= quantINT[qlevel]) {
xquant[i] = qlevel -1
stop = 1}
else {
qlevel = qlevel +1
}
}
}
# change into return(xquant)
# used fo consistency with quantentr
return(xquant-1)
}
Hquant(x, 5)
Ts1 = x
totLength = length(Ts1)
tmp = sort(Ts1, return.index=T)
Ts1[tmp$ix]=c(1:totLength)
tmp = sort(Ts1, index.return=T)
Ts1[tmp$ix]=c(1:totLength)
x
Ts1
Ts2 = rnorm(1000, 0, 1)
tmp = sort(Ts2, return.index=T)
tmp = sort(Ts2, index.return=T)
Ts2[tmp$ix]=c(1:totLength)
codeTs1 = (lev.q^(seq(from=(l1 -1), to= 0, by=-1))
)
lev.q= 5
l1 = 3
codeTs1 = (lev.q^(seq(from=(l1 -1), to= 0, by=-1)))
codeTs1
XX = c()
xx
XX
xx = c(XX, 1)
XX
XX = c(XX, 1)
XX
Ts2 = c(2, 5, 8, 4, 1, 4, 2, 5, 5, 2, 2, 5, 4, 8, 4, 1, 2, 5, 5, 2, 2, 2, 3, 4, 5, 6, 2, 1, 5, 4, 3, 2, 1, 1)
Ts2 = c(2, 5, 8, 4, 1, 4, 2, 5, 5, 2, 2, 5, 4, 8, 4, 1, 2, 5, 5, 2, 2, 2, 3, 4, 5, 6, 2, 1, 5, 4)
Ts1 = c(1, 10, 15, 8, 25, 26, 17, 9, 13, 19, 1, 10, 15, 8, 25, 26, 17, 9, 13, 19, 1, 10, 15, 8, 25, 26, 17, 9, 13, 19)
l1 = 4
l2 = 4
tlag1 = 2
tlag2 = 2
lev.q = 7
totLength = length(Ts1)
tmp = sort(Ts1, index.return=T)
Ts1[tmp$ix]=c(1:totLength)
tmp = sort(Ts2, index.return=T)
Ts2[tmp$ix]=c(1:totLength)
QTs1 = Hquant(Ts1, lev.q)
QTs2 = Hquant(Ts2, lev.q)
codeTs1 = (lev.q^(seq(from=(l1 -1), to= 0, by=-1))) #check for orientation
codeTs2 = (lev.q^(seq(from=(l2 -1), to= 0, by=-1)))
Xpat = c()
Ypat = c()
Yt   = c()
for (i in max(c(l1, tlag1)):min(c(length(QTs1),length(QTs2)))){
Xpat=c(Xpat, codeTs1[(i-l1-tlag1+1):(i-tlag1)]*QTs1)
Ypat=c(Ypat, codeTss[(i-l2-tlag2+1):(i-tlag2)]*QTs2)
Yt = c(Yt, codeTs2[i])
}
max(c(l1, tlag1))
min(c(length(QTs1),length(QTs2)))
max(c(l1, tlag1)):min(c(length(QTs1),length(QTs2)))
l1-tlag1+1
ls()
Ts2 = c(2, 5, 8, 4, 1, 4, 2, 5, 5, 2, 2, 5, 4, 8, 4, 1, 2, 5, 5, 2, 2, 2, 3, 4, 5, 6, 2, 1, 5, 4)
Ts1 = c(1, 10, 15, 8, 25, 26, 17, 9, 13, 19, 1, 10, 15, 8, 25, 26, 17, 9, 13, 19, 1, 10, 15, 8, 25, 26, 17, 9, 13, 19)
l1 = 1
l2 = 1
tlag1= 1
tlag2=1
totLength = length(Ts1)
tmp = sort(Ts1, index.return=T)
Ts1[tmp$ix]=c(1:totLength)
tmp = sort(Ts2, index.return=T)
Ts2[tmp$ix]=c(1:totLength)
fix(Ts1)
fix(Ts1)
table(Ts1, Ts2)
table(Ts1, Ts2) -> aa
edit(aa)
?table
table(Ts1, Ts2, Ts1)
Aye <- sample(c("Yes", "Si", "Oui"), 177, replace = TRUE)
Bee <- sample(c("Hum", "Buzz"), 177, replace = TRUE)
Sea <- sample(c("White", "Black", "Red", "Dead"), 177, replace = TRUE)
(A <- table(Aye, Bee, Sea))
ftable(A)
addmargins(A)
C1 = c(1,1,1,0,1,1, 0,1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1)
sum(C1)
C2 = c(1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1)
sum(C2)
C3 = c(NA, C1[2:22])
C3
xtabs(~ C1 + C2 + C3)
C3 = c(C1[2:22], NA)
xtabs(~ C1 + C2 + C3)
xtabs(~ C1 + C2 + C3, sparse=T)
table(C1, C2, C3)
ftable(C1, C2, C3)
ftable(C1, C2, C3) -> AA
aa
AA
fix(AA)
fix(AA)
fix(AA)
fix(AA)
fix(AA)
fix(AA)
as.matrix(AA)
as.matrix(AA) -> BB
BB
edit(BB)
BB/sum(BB)
rm(BB)
aa
AA
edit(AA)
ftable(C3, C1, C2) -> AA
AA
AA/sum(AA)
ftable
margin.table(AA, 1)
as.data.frame(AA)
as.data.frame(AA)$Freq/22
as.data.frame(AA)$Freq/20
sum(as.data.frame(AA)$Freq)
as.data.frame(AA)$Freq/21
as.data.frame(ftable(C3, C1))
as.data.frame(ftable(C3, C1))$Freq / 21
as.data.frame(ftable(C3, C1))$Freq / 21 -> C3C1
as.data.frame(AA)$Freq/21 -> C3C1C2
as.data.frame(ftable(C1, C2))$Freq / 22 -> C1C2
C1C2
as.data.frame(ftable(C1))$Freq / 22 -> C1
C1
ls()
C3C1C2*C1
C3C1C2*C1 -> numer
c(C1C2*C3*C1, C1C2*C3*C1)
c(C1C2*C3C1, C1C2*C3C1)
c(C1C2*C3C1, C1C2*C3C1) -> denom
sum(C3C1C2*log10(numer/denom))
(numer/denom)
numer
denom
numer[numer == 0] = 1
numer
denom[denom == 0] = 1
denom
sum(C3C1C2*log10(numer/denom))
cbind(C3C1C2, C1, C1C2, C3C1)
AA
as.data.frame(AA)
C3
log(C3)
C3C1C22 = C3C1C2
C3C1C22[C3C1C22 == 0] = 1
log10((C3C1C22*C1)/(C1C2*C3C1))
log10((C3C1C22*C1)/(C1C2*C3C1))*C3C1C2
sum(log10((C3C1C22*C1)/(C1C2*C3C1))*C3C1C2)
as.data.frame(table(C3, C1, C2))
ls()
C1
C1 = c(1,1,1,0,1,1, 0,1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1)
C2 = c(1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1)
trent<-function(Y,X, s=1){
# C1 = c(1,1,1,0,1,1, 0,1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1)
# C2 = c(1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1)
#
L4=L1=length(X) - s # Lengths of vectors
L3=L2=length(X)
#
# 1. p{Xn+s,Xn,Yn}
#
TPvector1=rep(0,L1)  # Init.
for (i in 1:L1)
{
TPvector1[i]=paste(c(X[i+s],"i",X[i],"i",Y[i]),collapse="") #  "addresses"
}
TPvector1T=table(TPvector1)/length(TPvector1)  # Table of probabilities,
#
# 2. p(Xn)
#
TPvector2 = X
TPvector2T = table(X)/sum(table(X))
#
# 3. p(Xn,Yn)
#
TPvector3=rep(0,L3)
for(i in 1:L3)
{
TPvector3[i]=paste(c(X[i], "i",Y[i]),collapse="")  # addresses
}
TPvector3T=table(TPvector3)/length(TPvector2)
#
# 4. p(Xn+s,Xn)
#
TPvector4=rep(0,L4)
for(i in 1:L4)
{
TPvector4[i]=paste(c(X[i+s], "i",X[i]),collapse="") # addresses
}
TPvector4T=table(TPvector4)/length(TPvector4)
#
# Transfer entropy T(Y->X) #
#
SUMvector = rep(0, length(TPvector1T))
for(n in  1:length(TPvector1T))
{
SUMvector[n]=TPvector1T[n]*log10((TPvector1T[n]*TPvector2T[(unlist(strsplit(names(TPvector1T)[n],"i")))[2]])/(TPvector3T[paste((unlist(strsplit(names(TPvector1T)[n],"i")))[2],"i",(unlist(strsplit(names(TPvector1T)[n],"i")))[3] ,sep="", collapse="")]*TPvector4T[paste((unlist(strsplit(names(TPvector1T)[n],"i")))[1],"i", (unlist(strsplit(names(TPvector1T)[n],"i")))[2],sep="",collapse="")]))
}
return(sum(SUMvector))
}
trent(C1, C2)
as.data.frame(table(C1, C2))
as.data.frame(table(C1))
C3 = c(1,1,0,1,1, 0,1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, NA)
as.data.frame(table(C3, C1))
as.data.frame(table(C2, C1, C3))
table(C1, C2)
as.matrix(table(C1, C2))
as.matrix(table(C1, C2)) --> butta
as.matrix(table(C1, C2)) -> butta
butta
is.matrix(butta)
edit(butta)
butta[1,1]
length(C3C1C2$Freq)
as.data.frame(table(C2, C1, C3))-> C3C1C2
length(C3C1C2$Freq)
as.matrix(Table(C1))
as.matrix(table(C1))
trent<-function(Y,X, s=1){
# C1 = c(1,1,1,0,1,1, 0,1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1)
# C2 = c(1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1)
# C3 = c(1,1,0,1,1, 0,1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, NA)
L4=L1=length(X) - s # Lengths of vectors
L3=L2=length(X)
#
# 1. p{Xn+s,Xn,Yn}
#
TPvector1=rep(0,L1)  # Init.
for (i in 1:L1)
{
TPvector1[i]=paste(c(X[i+s],"i",X[i],"i",Y[i]),collapse="") #  "addresses"
}
TPvector1T=table(TPvector1)/length(TPvector1)  # Table of probabilities,
#
# 2. p(Xn)
#
TPvector2 = X
TPvector2T = table(X)/sum(table(X))
#
# 3. p(Xn,Yn)
#
TPvector3=rep(0,L3)
for(i in 1:L3)
{
TPvector3[i]=paste(c(X[i], "i",Y[i]),collapse="")  # addresses
}
TPvector3T=table(TPvector3)/length(TPvector2)
#
# 4. p(Xn+s,Xn)
#
TPvector4=rep(0,L4)
for(i in 1:L4)
{
TPvector4[i]=paste(c(X[i+s], "i",X[i]),collapse="") # addresses
}
TPvector4T=table(TPvector4)/length(TPvector4)
#
# Transfer entropy T(Y->X) #
#
SUMvector = rep(0, length(TPvector1T))
for(n in  1:length(TPvector1T))
{
SUMvector[n]=TPvector1T[n]*log10((TPvector1T[n]*TPvector2T[(unlist(strsplit(names(TPvector1T)[n],"i")))[2]])/(TPvector3T[paste((unlist(strsplit(names(TPvector1T)[n],"i")))[2],"i",(unlist(strsplit(names(TPvector1T)[n],"i")))[3] ,sep="", collapse="")]*TPvector4T[paste((unlist(strsplit(names(TPvector1T)[n],"i")))[1],"i", (unlist(strsplit(names(TPvector1T)[n],"i")))[2],sep="",collapse="")]))
}
return(sum(SUMvector))
}
C1 = c(1,1,1,0,1,1, 0,1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1)
C2 = c(1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1)
C3 = c(1,1,0,1,1, 0,1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, NA)
Qts1 = C1
rm(Qts1)
QTs1 = C1
QTs12 = C3
QTs2 = C2
C3C1C2 = as.data.frame(table(QTs12, QTs1, QTs2))
C1     = as.matrix(table(QTs1))
C1C2   = as.matrix(table(QTs1, QTs2))
C3C1   = as.matrix(table(QTs3, QTs1))
C3C1   = as.matrix(table(QTs12, QTs1))
C3C1C2$Freq = C3C1C2$Freq / sum(C3C1C2$Freq)
sumINDEX = length(C3C1C2$Freq)
C1 = C1/sum(C1)
C1C2 = C1C2/sum(C1C2)
C3C1 = C3C1/sum(C3C1)
trH = 0
for (i in 1:length(sumINDEX)){
trH = c(trH, (C3C1C2[i, 4]*C1[C3C1C2[i, 2], 1])/(C1C2[C3C1C2[i, 2], C3C1C2[i, 3]]*C3C1[C3C1C2[i, 1], C3C1C2[i, 2]]))
}
trH
for (i in 1:sumINDEX){
trH = c(trH, (C3C1C2[i, 4]*C1[C3C1C2[i, 2], 1])/(C1C2[C3C1C2[i, 2], C3C1C2[i, 3]]*C3C1[C3C1C2[i, 1], C3C1C2[i, 2]]))
}
trH
trH[trH==0]=1
trH = sum(t(C3C1C2[, 4])*log10(trH))
trH = c()
for (i in 1:sumINDEX){
trH = c(trH, (C3C1C2[i, 4]*C1[C3C1C2[i, 2], 1])/(C1C2[C3C1C2[i, 2], C3C1C2[i, 3]]*C3C1[C3C1C2[i, 1], C3C1C2[i, 2]]))
}
trH[trH==0]=1
trH = sum(t(C3C1C2[, 4])*log10(trH))
unorm(10, 0, 1)
runif(10, 0, 1)
ceiling(runif(10, 0, 1))
floor
(runif(10, 0, 1))
floor(runif(10, 0, 1))
floor(runif(10, 0, 2))
QTs1 = floor(runif(100, 0, 3))
QTs2 = floor(runif(100, 0, 3))
QTs12 = c(QTs1[2:length(QTs1)], NA)
C3C1C2 = as.data.frame(table(QTs12, QTs1, QTs2))
C1     = as.matrix(table(QTs1))
C1C2   = as.matrix(table(QTs1, QTs2))
C3C1   = as.matrix(table(QTs12, QTs1))
# Transform into frequencies
C3C1C2$Freq = C3C1C2$Freq / sum(C3C1C2$Freq)
sumINDEX = length(C3C1C2$Freq)
C1 = C1/sum(C1)
C1C2 = C1C2/sum(C1C2)
C3C1 = C3C1/sum(C3C1)
trH = c()
for (i in 1:sumINDEX){
trH = c(trH, (C3C1C2[i, 4]*C1[C3C1C2[i, 2], 1])/(C1C2[C3C1C2[i, 2], C3C1C2[i, 3]]*C3C1[C3C1C2[i, 1], C3C1C2[i, 2]]))
}
trH[trH==0]=1
trH = sum(t(C3C1C2[, 4])*log10(trH))
QTs1 = floor(runif(1000, 0, 3))
QTs12 = c(QTs1[2:length(QTs1)], NA)
QTs2 = floor(runif(1000, 0, 3))
C3C1C2 = as.data.frame(table(QTs12, QTs1, QTs2))
C1     = as.matrix(table(QTs1))
C1C2   = as.matrix(table(QTs1, QTs2))
C3C1   = as.matrix(table(QTs12, QTs1))
# Transform into frequencies
C3C1C2$Freq = C3C1C2$Freq / sum(C3C1C2$Freq)
sumINDEX = length(C3C1C2$Freq)
C1 = C1/sum(C1)
C1C2 = C1C2/sum(C1C2)
C3C1 = C3C1/sum(C3C1)
trH = c()
for (i in 1:sumINDEX){
trH = c(trH, (C3C1C2[i, 4]*C1[C3C1C2[i, 2], 1])/(C1C2[C3C1C2[i, 2], C3C1C2[i, 3]]*C3C1[C3C1C2[i, 1], C3C1C2[i, 2]]))
}
trH[trH==0]=1
trH = sum(t(C3C1C2[, 4])*log10(trH))
QTs1 = floor(runif(10, 0, 15))
QTs1
QTs1 = floor(runif(100, 0, 15))
QTs2 = floor(runif(100, 0, 15))
QTs12 = c(QTs1[2:length(QTs1)], NA)
C3C1C2 = as.data.frame(table(QTs12, QTs1, QTs2))
C1     = as.matrix(table(QTs1))
C1C2   = as.matrix(table(QTs1, QTs2))
C3C1   = as.matrix(table(QTs12, QTs1))
# Transform into frequencies
C3C1C2$Freq = C3C1C2$Freq / sum(C3C1C2$Freq)
sumINDEX = length(C3C1C2$Freq)
C1 = C1/sum(C1)
C1C2 = C1C2/sum(C1C2)
C3C1 = C3C1/sum(C3C1)
trH = c()
for (i in 1:sumINDEX){
trH = c(trH, (C3C1C2[i, 4]*C1[C3C1C2[i, 2], 1])/(C1C2[C3C1C2[i, 2], C3C1C2[i, 3]]*C3C1[C3C1C2[i, 1], C3C1C2[i, 2]]))
}
trH[trH==0]=1
trH = sum(t(C3C1C2[, 4])*log10(trH))
trH = c()
for (i in 1:sumINDEX){
trH = c(trH, (C3C1C2[i, 4]*C1[C3C1C2[i, 2], 1])/(C1C2[C3C1C2[i, 2], C3C1C2[i, 3]]*C3C1[C3C1C2[i, 1], C3C1C2[i, 2]]))
}
sumINDEX
C3C1C2[i, 4]*C1[C3C1C2[i, 2], 1]
C1C2[C3C1C2[i, 2], C3C1C2[i, 3]]*C3C1[C3C1C2[i, 1], C3C1C2[i, 2]]
trH
C3C1C2
t(C3C1C2[, 4]
)
trH
trH[trH==0]=1
trH[is.nan(trH)]=1
trH = sum(t(C3C1C2[, 4])*log10(trH))
QTs2 = floor(runif(1000, 0, 15))
QTs1 = floor(runif(1000, 0, 15))
QTs12 = c(QTs1[2:length(QTs1)], NA)
C3C1C2 = as.data.frame(table(QTs12, QTs1, QTs2))
C1     = as.matrix(table(QTs1))
C1C2   = as.matrix(table(QTs1, QTs2))
C3C1   = as.matrix(table(QTs12, QTs1))
# Transform into frequencies
C3C1C2$Freq = C3C1C2$Freq / sum(C3C1C2$Freq)
sumINDEX = length(C3C1C2$Freq)
C1 = C1/sum(C1)
C1C2 = C1C2/sum(C1C2)
C3C1 = C3C1/sum(C3C1)
trH = c()
for (i in 1:sumINDEX){
trH = c(trH, (C3C1C2[i, 4]*C1[C3C1C2[i, 2], 1])/(C1C2[C3C1C2[i, 2], C3C1C2[i, 3]]*C3C1[C3C1C2[i, 1], C3C1C2[i, 2]]))
}
trH[trH==0]=1
trH[is.nan(trH)]=1
trH = sum(t(C3C1C2[, 4])*log10(trH))
QTs1 = floor(runif(10000, 0, 15))
QTs2 = floor(runif(10000, 0, 15))
QTs12 = c(QTs1[2:length(QTs1)], NA)
C3C1C2 = as.data.frame(table(QTs12, QTs1, QTs2))
C1     = as.matrix(table(QTs1))
C1C2   = as.matrix(table(QTs1, QTs2))
C3C1   = as.matrix(table(QTs12, QTs1))
# Transform into frequencies
C3C1C2$Freq = C3C1C2$Freq / sum(C3C1C2$Freq)
sumINDEX = length(C3C1C2$Freq)
C1 = C1/sum(C1)
C1C2 = C1C2/sum(C1C2)
C3C1 = C3C1/sum(C3C1)
trH = c()
for (i in 1:sumINDEX){
trH = c(trH, (C3C1C2[i, 4]*C1[C3C1C2[i, 2], 1])/(C1C2[C3C1C2[i, 2], C3C1C2[i, 3]]*C3C1[C3C1C2[i, 1], C3C1C2[i, 2]]))
}
trH[trH==0]=1
trH[is.nan(trH)]=1
trH = sum(t(C3C1C2[, 4])*log10(trH))
QTs2 = floor(runif(100000, 0, 15))
QTs1 = floor(runif(100000, 0, 15))
QTs12 = c(QTs1[2:length(QTs1)], NA)
C3C1C2 = as.data.frame(table(QTs12, QTs1, QTs2))
C1     = as.matrix(table(QTs1))
C1C2   = as.matrix(table(QTs1, QTs2))
C3C1   = as.matrix(table(QTs12, QTs1))
# Transform into frequencies
C3C1C2$Freq = C3C1C2$Freq / sum(C3C1C2$Freq)
sumINDEX = length(C3C1C2$Freq)
C1 = C1/sum(C1)
C1C2 = C1C2/sum(C1C2)
C3C1 = C3C1/sum(C3C1)
trH = c()
for (i in 1:sumINDEX){
trH = c(trH, (C3C1C2[i, 4]*C1[C3C1C2[i, 2], 1])/(C1C2[C3C1C2[i, 2], C3C1C2[i, 3]]*C3C1[C3C1C2[i, 1], C3C1C2[i, 2]]))
}
trH[trH==0]=1
trH[is.nan(trH)]=1
trH = sum(t(C3C1C2[, 4])*log10(trH))
